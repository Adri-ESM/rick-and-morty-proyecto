{"ast":null,"code":"import { ADD_FAVORITES } from \"./actions_types\";\nimport { REMOVE_FAVORITES } from \"./actions_types\";\n\n// export const addFavorite = (id) => async (dispatch) => {\n//   try {\n//       const response = await fetch('http://localhost:3001/rickandmorty/fav', {\n//           method: 'POST',\n//           headers: {\n//               'Content-Type': 'application/x-www-form-urlencoded'\n//           },\n//           body: { id }\n//       });\n\n//       if (response.ok) {\n//         const data = id;\n//           // const data = await response.json();\n//           dispatch({\n//               type: ADD_FAVORITES,\n//               payload: data,\n//           });\n//       } else {\n//           throw new Error(`HTTP error! status: ${response.status}`);\n//       }\n//   } catch (error) {\n//       console.log(error);\n//   }\n// };\n\n// export const removeFavorite = (id) => async (dispatch) => {\n//     try {\n//       const response = await fetch(`http://localhost:3001/rickandmorty/fav/${id}`, {\n//         method: 'DELETE',\n//       });\n\n//       if (response.ok){\n//       // const data = await response.json();\n//       const data = id;\n//       dispatch({\n//         type: REMOVE_FAVORITES,\n//         payload: data,\n//       });\n//     } else {\n//         throw new Error(`HTTP error! status: ${response.status}`);\n//     }\n//     }catch (error) {\n//       console.log(error);\n//     }\n//   };\n\n// export const addFavorite = (id) => {\n//     return {\n//         type: 'ADD_FAVORITES',\n//         payload: id,\n//     }\n// }\n\n// export const removeFavorite = (id) => {\n//     return {\n//         type: 'REMOVE_FAVORITES',\n//         payload: id,\n//     }\n// }\n\n//   Aquí, estamos actualizando la acción addFavorite para que acepte un \n//   objeto character que contiene los detalles del personaje que deseas \n//   agregar a la lista de favoritos. Luego, estamos utilizando la biblioteca \n//   fetch para enviar una solicitud HTTP POST al endpoint \n//   http://localhost:3001/rickandmorty/fav, incluyendo el objeto character \n//   en el cuerpo de la solicitud en formato JSON.\n\n// Si la solicitud es exitosa, el servidor devolverá un objeto que contiene \n// un id único para el personaje que se ha agregado a la lista de favoritos. \n// Luego, estamos actualizando el estado de la aplicación llamando a la \n// acción ADD_FAVORITES y pasando el id del personaje agregado como carga útil.\n\n// Ten en cuenta que necesitarás actualizar el código de tu componente para \n// pasar el objeto character a la acción addFavorite.\n\n// async/await es una característica de JavaScript que permite escribir código \n// asíncrono en un estilo síncrono. async se usa para declarar una función asíncrona, \n// lo que significa que la función devuelve una promesa que puede ser resuelta en un \n// valor en el futuro. await se usa dentro de una función asíncrona para esperar que \n// una promesa se resuelva antes de continuar ejecutando el código.\n\n// Con async/await, puedes escribir código asíncrono de una manera más fácil de \n// entender y menos propensa a errores. En lugar de encadenar varias llamadas a \n// funciones que devuelven promesas, puedes usar await para esperar a que se resuelva \n// una promesa antes de continuar con la siguiente línea de código. Además, los errores \n// se pueden capturar y manejar fácilmente con bloques try/catch.","map":{"version":3,"names":["ADD_FAVORITES","REMOVE_FAVORITES"],"sources":["/Users/asanchez/Desktop/desktop/CURSOS/soy-henry/MODULO-2/rick-and-morty-proyecto/front/src/redux/actions.js"],"sourcesContent":["import { ADD_FAVORITES } from \"./actions_types\";\nimport { REMOVE_FAVORITES } from \"./actions_types\";\n\n\n// export const addFavorite = (id) => async (dispatch) => {\n//   try {\n//       const response = await fetch('http://localhost:3001/rickandmorty/fav', {\n//           method: 'POST',\n//           headers: {\n//               'Content-Type': 'application/x-www-form-urlencoded'\n//           },\n//           body: { id }\n//       });\n\n//       if (response.ok) {\n//         const data = id;\n//           // const data = await response.json();\n//           dispatch({\n//               type: ADD_FAVORITES,\n//               payload: data,\n//           });\n//       } else {\n//           throw new Error(`HTTP error! status: ${response.status}`);\n//       }\n//   } catch (error) {\n//       console.log(error);\n//   }\n// };\n\n\n// export const removeFavorite = (id) => async (dispatch) => {\n//     try {\n//       const response = await fetch(`http://localhost:3001/rickandmorty/fav/${id}`, {\n//         method: 'DELETE',\n//       });\n      \n//       if (response.ok){\n//       // const data = await response.json();\n//       const data = id;\n//       dispatch({\n//         type: REMOVE_FAVORITES,\n//         payload: data,\n//       });\n//     } else {\n//         throw new Error(`HTTP error! status: ${response.status}`);\n//     }\n//     }catch (error) {\n//       console.log(error);\n//     }\n//   };\n\n  // export const addFavorite = (id) => {\n//     return {\n//         type: 'ADD_FAVORITES',\n//         payload: id,\n//     }\n// }\n\n// export const removeFavorite = (id) => {\n//     return {\n//         type: 'REMOVE_FAVORITES',\n//         payload: id,\n//     }\n// }\n\n//   Aquí, estamos actualizando la acción addFavorite para que acepte un \n//   objeto character que contiene los detalles del personaje que deseas \n//   agregar a la lista de favoritos. Luego, estamos utilizando la biblioteca \n//   fetch para enviar una solicitud HTTP POST al endpoint \n//   http://localhost:3001/rickandmorty/fav, incluyendo el objeto character \n//   en el cuerpo de la solicitud en formato JSON.\n\n// Si la solicitud es exitosa, el servidor devolverá un objeto que contiene \n// un id único para el personaje que se ha agregado a la lista de favoritos. \n// Luego, estamos actualizando el estado de la aplicación llamando a la \n// acción ADD_FAVORITES y pasando el id del personaje agregado como carga útil.\n\n// Ten en cuenta que necesitarás actualizar el código de tu componente para \n// pasar el objeto character a la acción addFavorite.\n\n// async/await es una característica de JavaScript que permite escribir código \n// asíncrono en un estilo síncrono. async se usa para declarar una función asíncrona, \n// lo que significa que la función devuelve una promesa que puede ser resuelta en un \n// valor en el futuro. await se usa dentro de una función asíncrona para esperar que \n// una promesa se resuelva antes de continuar ejecutando el código.\n\n// Con async/await, puedes escribir código asíncrono de una manera más fácil de \n// entender y menos propensa a errores. En lugar de encadenar varias llamadas a \n// funciones que devuelven promesas, puedes usar await para esperar a que se resuelva \n// una promesa antes de continuar con la siguiente línea de código. Además, los errores \n// se pueden capturar y manejar fácilmente con bloques try/catch."],"mappings":"AAAA,SAASA,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,gBAAgB,QAAQ,iBAAiB;;AAGlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}